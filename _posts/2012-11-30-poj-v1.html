---
layout: post
title: v1
category: POJ
tags:
date: 2012-11-30 15:35:24 CST
---
<div id="preamble">

</div>

<div id="content">
<h1 class="title">POJ v1</h1>

<p><i>NOTE</i>: For the source codes, <a href="http://github.com/gongzhitaao/AC-Report">http://github.com/gongzhitaao/AC-Report</a>.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 1010 Stamps</a>
<ul>
<li><a href="#sec-1-1">1.1 An interpretation of the problem</a></li>
<li><a href="#sec-1-2">1.2 Some notes</a></li>
<li><a href="#sec-1-3">1.3 Crack it</a></li>
</ul>
</li>
<li><a href="#sec-2">2 1009 Edge Detection</a></li>
<li><a href="#sec-3">3 1008 Maya Calendar</a></li>
<li><a href="#sec-4">4 1001 Exponentiation</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 1010 Stamps</h2>
<div class="outline-text-2" id="text-1">

<p> <span class="timestamp-wrapper"> <span class="timestamp">2012-11-30 Fri 14:36</span></span><br/>
</p>
<p>
For the problem: <a href="http://poj.org/problem?id=1010">http://poj.org/problem?id=1010</a>.
</p>
<p>
Holly shit! Totally I spent more than 24 hours on this problem.
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> An interpretation of the problem</h3>
<div class="outline-text-3" id="text-1-1">


<ol>
<li>Given a sequence containing only positives, say, <code>3 2 1 1 1 1</code>, and
   a number, you should pick at most <b>FOUR</b> numbers from the sequence
   that adds up to the given number. The numbers from the sequence are
   reusable.
</li>
<li>If no solution exists, print <code>none</code>. Otherwise, find the best
   one(s) from the results you find with the following rules, in
   sequence:

<ol>
<li>the most type count
</li>
<li>the least total stamp count
</li>
<li>the max single value

</li>
</ol>

<p>   After this filtering, a) if only one result exists, print it. b) or
   if more than one result exists, print <code>tie</code>.
</p></li>
</ol>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Some notes</h3>
<div class="outline-text-3" id="text-1-2">


<ol>
<li>We have different types of stamps, according to the specification
   of the problem, no more than 25 types of stamps. But according to
   google search results of <b>poj 1010</b>, most people believe that this
   is misleading. Actual test cases might contain more than 25
   types. Never mind, use <code>vector</code> to bypass this.
</li>
<li>Every type of stamp has a positive denomination. There might be
   different types of stamps with the same denomination, i.e., the
   following test case is valid:


<p class="verse">
</p><pre class="example">
1 1 1 1 1 0
</pre>




<p>
   which means that we have 5 different types of stamps, all with the
   same denomination.
</p>
<p>
   So, one of the example input is wrong:
</p>

<p class="verse">
</p><pre class="example">
1 1 0 ; a new set of stamps (two of the same type)
</pre>




<p>
   They are of different types, only with the same denomination. This
   is really misleading!
</p></li>
</ol>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Crack it</h3>
<div class="outline-text-3" id="text-1-3">


<p>
This is a search problem. In the most unlucky case, you've got to
search through the whole solution set. Firstly, what is the solution
set? <b>All sequences you could find that adds up to the given value</b>.
</p>
<p>
How to search for the result? It's a problem of <a href="http://en.wikipedia.org/wiki/Combination">Combination</a>. Pick, say
3 numbers from the given sequence, and try using a total stamp count,
say, 4, see whether you could add up to the request value. If yes,
you've found an answer, do something to judge the answer, otherwise
continue.
</p>
<p>
Because in the end, we want to find the <b>best</b> answer s.t. the rules
given above. So we can adjust our search strategy so that once we find
an answer, we can stop searching. The strategy is as follows:
</p>
<ol>
<li>Sort the given stamp value sequence in non-descending order.
</li>
<li>search in the following fashion:




<pre class="src src-c++"><span style="color: #babdb6; font-style: italic;">// </span><span style="color: #babdb6; font-style: italic;">we want the most stamp type count</span>
<span style="color: #729fcf; font-weight: bold;">for</span> (<span style="color: #73d216; font-weight: bold;">int</span> <span style="color: #ef2929;">i</span> = max_possible_type_count; i &gt;= 0; --i) {
    <span style="color: #babdb6; font-style: italic;">// </span><span style="color: #babdb6; font-style: italic;">we want the least total stamp count</span>
    <span style="color: #729fcf; font-weight: bold;">for</span> (<span style="color: #73d216; font-weight: bold;">int</span> <span style="color: #ef2929;">j</span> = i; j &lt; 4; ++j) {
        <span style="color: #babdb6; font-style: italic;">/* </span><span style="color: #babdb6; font-style: italic;">generate possible combinations here, larger value first.</span>
<span style="color: #babdb6; font-style: italic;">         *</span>
<span style="color: #babdb6; font-style: italic;">         * Say, we have stamp value sequence(sorted): 1, 2, 3, 3, 4, 6</span>
<span style="color: #babdb6; font-style: italic;">         *</span>
<span style="color: #babdb6; font-style: italic;">         * So, the sequences(index) we should generate are: 5 4 3, 5 4</span>
<span style="color: #babdb6; font-style: italic;">         * 2, 5 4 1, 5 4 0, 5 3 2, 5 3 1, 5 3 0, ...  and so on.</span>
<span style="color: #babdb6; font-style: italic;">         *</span>
<span style="color: #babdb6; font-style: italic;">         * Try each one in sequence, once we find an answer or a tie,</span>
<span style="color: #babdb6; font-style: italic;">         * return.</span>
<span style="color: #babdb6; font-style: italic;">         */</span>
    }
 }
</pre>

</li>
</ol>



</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 1009 Edge Detection</h2>
<div class="outline-text-2" id="text-2">

<p> <span class="timestamp-wrapper"> <span class="timestamp">2012-11-07 Wed 08:30</span></span><br/>
</p>
<p>
For the problem: <a href="http://poj.org/problem?id=1009">http://poj.org/problem?id=1009</a>.
</p>
<p>
It took me three days. I even wrote a test framework for it in my
Makefile.
</p>
<p>
The idea is simple: for given a pixel, I need its surrounding 8
pixels. The problem is that I could not iterate pixel by pixel
considering the run length, 10<sup>9</sup>. The solution is to calculate only
the boundery points. For example:
</p>

<p class="verse">
</p><pre class="example">
0 0 0 1 1 1 0 0 0
    ^ ^   ^ ^      these are boundery points
</pre>




<ol>
<li>One boundery point affects its surrounding 8 points. So, the
   surrounding points might contribute to the output.


<p class="verse">
</p><pre class="example">
. . . . . . . . .
. . . b b b . . .
. . . b x b . . .
. . . b b b . . .
. . . . . . . . .
</pre>




</li>
<li>Only potential points and its surrounding ones might contribute to
   output.

</li>
<li>The starting boundery points in the input is a potential one.


<p class="verse">
</p><pre class="example">
. . b b a a a a a a . . .
        ^ potential one
</pre>




</li>
<li>Another potential output points is:


<p class="verse">
</p><pre class="example">
a a . . . b b b b
b b b . . . . . .
^  potential one
</pre>




</li>
</ol>



</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 1008 Maya Calendar</h2>
<div class="outline-text-2" id="text-3">

<p> <span class="timestamp-wrapper"> <span class="timestamp">2012-11-02 Fri 20:23</span></span><br/>
</p>
<p>
Trivial.
</p>

</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 1001 Exponentiation</h2>
<div class="outline-text-2" id="text-4">

<p> <span class="timestamp-wrapper"> <span class="timestamp">2012-11-02 Fri 16:51</span></span><br/>
</p>
<p>
For the problem: <a href="http://poj.org/problem?id=1001">http://poj.org/problem?id=1001</a>.
</p>
<p>
Two things to implement:
</p>
<ol>
<li>Manually multiply two integers in string form. There are many
   <a href="http://en.wikipedia.org/wiki/Multiplication_algorithm">Multiplication Algorithm</a>s, just choose one you like :)

</li>
<li>Do Binary Exponentiation, i.e. <a href="http://en.wikipedia.org/wiki/Exponentiation_by_squaring">Expenetiatiion By Squaring</a>. Which is
   clearly illustrated <a href="http://mathforum.org/library/drmath/view/55603.html">here</a>:

<p>
   The fastest exponentiations to perform are exponentiations of the
   type a<sup>2</sup><sup>n</sup>, that is, where the exponent is a power of two. This is
   because you can find these powers by repeatedly squaring the
   number. So I can find 5<sup>2</sup> with only one multiplication, 5<sup>4</sup> =
   (5<sup>2</sup>)<sup>2</sup> with only two, 5<sup>8</sup> = ((5<sup>2</sup>)<sup>2</sup>)<sup>2</sup> in three, and so
   forth. This leads to the method of binary exponentiation:
</p>
<ol>
<li>Write the exponent as a sum of powers of two.
</li>
<li>Find the base to each of the powers of two that appear in the
      exponent.
</li>
<li>Multiply those powers together.

</li>
</ol>

<p>   To illustrate with 5<sup>21</sup>:
</p>

<p class="verse">
</p><pre class="example">
1) 21 = 16 + 4 + 1
2) 5^1 = 5
   5^2 = 5*5 = 25
   5^4 = 25 * 25 = 625
   5^8 = 625 * 625 = 390625
   5^16 = 390625 * 390625 = 152587890625
3) 5^21 = 5^16 * 5^4 * 5 = 476837158203125
</pre>




</li>
</ol>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-11-30 15:35:24 CST</p>
<p class="author">Author: Zhitao Gong</p>
<p class="creator">Org version 7.8.02 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
